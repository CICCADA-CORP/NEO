//! C2PA content credentials for NEO files.
//!
//! Implements the credential storage format defined in SPECIFICATION.md Section 10.
//!
//! The NEO format stores C2PA manifests as raw JUMBF (JPEG Universal Metadata Box Format)
//! blobs in the CRED chunk. This module provides:
//!
//! - `NeoCredentials`: Metadata about content origin and provenance
//! - `ContentOrigin`: Enum indicating human/AI/hybrid creation
//! - Raw JUMBF blob storage for the CRED chunk
//!
//! # Design
//!
//! The heavy `c2pa` crate (~300 transitive dependencies) is NOT required.
//! This module handles credential metadata and raw JUMBF storage. Full C2PA
//! manifest creation and cryptographic verification can be enabled via an
//! optional `c2pa` feature flag in a future release.
//!
//! # Security
//!
//! Per SPECIFICATION.md Section 10: "Verification failure MUST NOT prevent playback."
//! Applications should warn users but continue playing audio if credentials fail to verify.

use serde::{Deserialize, Serialize};

use crate::error::{MetadataError, Result};

/// Content origin classification per C2PA assertions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ContentOrigin {
    /// Content was created entirely by a human.
    Human,
    /// Content was generated by AI/ML tools.
    Ai,
    /// Content was created with a mix of human and AI involvement.
    Hybrid,
}

/// C2PA content credentials for a NEO file.
///
/// Stores provenance information and an optional raw JUMBF manifest blob.
/// The JUMBF blob is stored in the CRED chunk of the NEO container and
/// is NOT included in JSON serialization (it's binary data).
///
/// # Example
/// ```
/// use neo_metadata::{NeoCredentials, ContentOrigin};
///
/// let creds = NeoCredentials::new(ContentOrigin::Human)
///     .with_creator("Alice Producer")
///     .with_created_at("2025-06-15T12:00:00Z")
///     .with_software("NEO CLI v0.1.0");
///
/// // Metadata serializes to JSON (without the JUMBF blob)
/// let json = creds.to_json_pretty().unwrap();
/// assert!(json.contains("human"));
///
/// // JUMBF blob is stored separately in the CRED chunk
/// assert!(creds.jumbf_manifest().is_none());
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NeoCredentials {
    /// Content origin classification.
    pub origin: ContentOrigin,

    /// Name of the content creator.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creator: Option<String>,

    /// ISO 8601 timestamp of content creation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,

    /// Software used to create the content.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub software: Option<String>,

    /// Human-readable description of the content's provenance.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Raw JUMBF manifest bytes (NOT serialized to JSON).
    ///
    /// This blob is stored in the CRED chunk of the NEO file.
    /// It contains the full C2PA manifest in JUMBF format for
    /// cryptographic verification by C2PA-aware applications.
    #[serde(skip)]
    manifest_bytes: Option<Vec<u8>>,
}

/// Summary of a C2PA credential for display purposes.
///
/// A lightweight, fully-serializable view of credentials
/// (without the raw JUMBF blob) suitable for CLI output or APIs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct CredentialSummary {
    /// Content origin classification.
    pub origin: ContentOrigin,

    /// Creator name, if known.
    pub creator: Option<String>,

    /// Creation timestamp, if known.
    pub created_at: Option<String>,

    /// Software used, if known.
    pub software: Option<String>,

    /// Whether a JUMBF manifest is present.
    pub has_manifest: bool,

    /// Size of the JUMBF manifest in bytes (0 if not present).
    pub manifest_size: usize,
}

// ── Builders ───────────────────────────────────────────────────────────────

impl NeoCredentials {
    /// Creates new credentials with the given origin.
    pub fn new(origin: ContentOrigin) -> Self {
        Self {
            origin,
            creator: None,
            created_at: None,
            software: None,
            description: None,
            manifest_bytes: None,
        }
    }

    /// Sets the creator name.
    pub fn with_creator(mut self, creator: impl Into<String>) -> Self {
        self.creator = Some(creator.into());
        self
    }

    /// Sets the creation timestamp (ISO 8601).
    pub fn with_created_at(mut self, timestamp: impl Into<String>) -> Self {
        self.created_at = Some(timestamp.into());
        self
    }

    /// Sets the software identifier.
    pub fn with_software(mut self, software: impl Into<String>) -> Self {
        self.software = Some(software.into());
        self
    }

    /// Sets the provenance description.
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Attaches a raw JUMBF manifest blob.
    ///
    /// This blob will be stored in the CRED chunk of the NEO file
    /// but will NOT be included in JSON serialization.
    pub fn with_manifest(mut self, bytes: Vec<u8>) -> Self {
        self.manifest_bytes = Some(bytes);
        self
    }

    /// Returns a reference to the raw JUMBF manifest bytes, if present.
    pub fn jumbf_manifest(&self) -> Option<&[u8]> {
        self.manifest_bytes.as_deref()
    }

    /// Consumes self and returns the JUMBF manifest bytes, if present.
    pub fn into_jumbf_manifest(self) -> Option<Vec<u8>> {
        self.manifest_bytes
    }

    /// Returns whether a JUMBF manifest is attached.
    pub fn has_manifest(&self) -> bool {
        self.manifest_bytes.is_some()
    }

    /// Returns a display-friendly summary of these credentials.
    pub fn summary(&self) -> CredentialSummary {
        CredentialSummary {
            origin: self.origin,
            creator: self.creator.clone(),
            created_at: self.created_at.clone(),
            software: self.software.clone(),
            has_manifest: self.manifest_bytes.is_some(),
            manifest_size: self.manifest_bytes.as_ref().map_or(0, |b| b.len()),
        }
    }

    /// Serializes the credential metadata to a JSON string.
    ///
    /// Note: The JUMBF manifest blob is NOT included in JSON output.
    /// It must be stored separately in the CRED chunk.
    pub fn to_json(&self) -> Result<String> {
        serde_json::to_string(self).map_err(MetadataError::from)
    }

    /// Serializes the credential metadata to a pretty-printed JSON string.
    pub fn to_json_pretty(&self) -> Result<String> {
        serde_json::to_string_pretty(self).map_err(MetadataError::from)
    }

    /// Deserializes credential metadata from a JSON string.
    ///
    /// Note: The JUMBF manifest must be loaded separately from the CRED chunk.
    pub fn from_json(json: &str) -> Result<Self> {
        serde_json::from_str(json).map_err(MetadataError::from)
    }

    /// Validates this credential.
    ///
    /// Checks:
    /// - If `created_at` is set, it looks like an ISO 8601 timestamp
    /// - If manifest is present, it is not empty
    pub fn validate(&self) -> Result<()> {
        if let Some(ref ts) = self.created_at {
            // Basic ISO 8601 check: must contain at least a date-like pattern
            if ts.len() < 10 || ts.chars().nth(4).is_none_or(|c| c != '-') {
                return Err(MetadataError::OutOfRange {
                    field: "created_at".to_string(),
                    value: ts.clone(),
                    expected: "ISO 8601 timestamp (e.g., 2025-06-15T12:00:00Z)".to_string(),
                });
            }
        }

        if let Some(ref manifest) = self.manifest_bytes {
            if manifest.is_empty() {
                return Err(MetadataError::CredentialError(
                    "JUMBF manifest is empty".to_string(),
                ));
            }
        }

        Ok(())
    }

    /// Creates credentials from a CRED chunk.
    ///
    /// The CRED chunk in the NEO file contains the raw JUMBF manifest bytes.
    /// The credential metadata (origin, creator, etc.) is stored in the META
    /// chunk or inferred from the JUMBF content.
    ///
    /// For now, this creates a basic credential with the raw bytes attached.
    /// Full JUMBF parsing will be available when the `c2pa` feature is enabled.
    pub fn from_cred_chunk(bytes: Vec<u8>) -> Self {
        Self {
            origin: ContentOrigin::Human, // Default; would be parsed from JUMBF
            creator: None,
            created_at: None,
            software: None,
            description: None,
            manifest_bytes: Some(bytes),
        }
    }
}

impl Default for NeoCredentials {
    fn default() -> Self {
        Self::new(ContentOrigin::Human)
    }
}

impl std::fmt::Display for ContentOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ContentOrigin::Human => write!(f, "human"),
            ContentOrigin::Ai => write!(f, "ai"),
            ContentOrigin::Hybrid => write!(f, "hybrid"),
        }
    }
}

// ── Tests ──────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_credentials_new() {
        let creds = NeoCredentials::new(ContentOrigin::Human);
        assert_eq!(creds.origin, ContentOrigin::Human);
        assert!(creds.creator.is_none());
        assert!(!creds.has_manifest());
    }

    #[test]
    fn test_credentials_builder_chain() {
        let creds = NeoCredentials::new(ContentOrigin::Ai)
            .with_creator("AI Model v2")
            .with_created_at("2025-06-15T12:00:00Z")
            .with_software("NEO CLI v0.1.0")
            .with_description("Generated from text prompt");

        assert_eq!(creds.origin, ContentOrigin::Ai);
        assert_eq!(creds.creator.as_deref(), Some("AI Model v2"));
        assert_eq!(creds.software.as_deref(), Some("NEO CLI v0.1.0"));
    }

    #[test]
    fn test_credentials_with_manifest() {
        let manifest = vec![0x4A, 0x55, 0x4D, 0x42]; // "JUMB"
        let creds = NeoCredentials::new(ContentOrigin::Hybrid).with_manifest(manifest.clone());

        assert!(creds.has_manifest());
        assert_eq!(creds.jumbf_manifest(), Some(manifest.as_slice()));
    }

    #[test]
    fn test_credentials_json_round_trip() {
        let creds = NeoCredentials::new(ContentOrigin::Human)
            .with_creator("Test Artist")
            .with_created_at("2025-01-01T00:00:00Z")
            .with_manifest(vec![1, 2, 3, 4]);

        let json = creds.to_json_pretty().unwrap();
        assert!(json.contains("human"));
        assert!(json.contains("Test Artist"));
        // Manifest should NOT be in JSON
        assert!(!json.contains("[1,2,3,4]"));

        let parsed = NeoCredentials::from_json(&json).unwrap();
        assert_eq!(parsed.origin, ContentOrigin::Human);
        assert_eq!(parsed.creator.as_deref(), Some("Test Artist"));
        // Manifest is lost after JSON round-trip (by design)
        assert!(!parsed.has_manifest());
    }

    #[test]
    fn test_credentials_summary() {
        let creds = NeoCredentials::new(ContentOrigin::Hybrid)
            .with_creator("Producer")
            .with_manifest(vec![0; 1024]);

        let summary = creds.summary();
        assert_eq!(summary.origin, ContentOrigin::Hybrid);
        assert!(summary.has_manifest);
        assert_eq!(summary.manifest_size, 1024);
    }

    #[test]
    fn test_credentials_validate_ok() {
        let creds = NeoCredentials::new(ContentOrigin::Human)
            .with_created_at("2025-06-15T12:00:00Z")
            .with_manifest(vec![1, 2, 3]);

        assert!(creds.validate().is_ok());
    }

    #[test]
    fn test_credentials_validate_bad_timestamp() {
        let creds = NeoCredentials::new(ContentOrigin::Human).with_created_at("not-a-date");

        assert!(creds.validate().is_err());
    }

    #[test]
    fn test_credentials_validate_empty_manifest() {
        let creds = NeoCredentials::new(ContentOrigin::Human).with_manifest(vec![]);

        let err = creds.validate().unwrap_err();
        assert!(err.to_string().contains("empty"));
    }

    #[test]
    fn test_credentials_from_cred_chunk() {
        let raw = vec![0x4A, 0x55, 0x4D, 0x42, 0xFF];
        let creds = NeoCredentials::from_cred_chunk(raw.clone());

        assert!(creds.has_manifest());
        assert_eq!(creds.jumbf_manifest().unwrap(), &raw);
    }

    #[test]
    fn test_credentials_into_manifest() {
        let manifest = vec![1, 2, 3, 4, 5];
        let creds = NeoCredentials::new(ContentOrigin::Human).with_manifest(manifest.clone());

        let extracted = creds.into_jumbf_manifest();
        assert_eq!(extracted, Some(manifest));
    }

    #[test]
    fn test_content_origin_display() {
        assert_eq!(ContentOrigin::Human.to_string(), "human");
        assert_eq!(ContentOrigin::Ai.to_string(), "ai");
        assert_eq!(ContentOrigin::Hybrid.to_string(), "hybrid");
    }

    #[test]
    fn test_content_origin_serde() {
        let json = serde_json::to_string(&ContentOrigin::Ai).unwrap();
        assert_eq!(json, "\"ai\"");

        let parsed: ContentOrigin = serde_json::from_str("\"hybrid\"").unwrap();
        assert_eq!(parsed, ContentOrigin::Hybrid);
    }

    #[test]
    fn test_credentials_default() {
        let creds = NeoCredentials::default();
        assert_eq!(creds.origin, ContentOrigin::Human);
        assert!(!creds.has_manifest());
    }
}
